# C01: snake_case
La convenci√≥n general es escribirlo en "**snake_case**": `MyVariable` = `my_variable`.
# C02: Anotacion de Tipo
Es una caracteristica a√±adida en **Pyton 3.5**. El cual permite anotar las **variables, funciones, argumentos y retornos con tipos**, como una forma de documentaci√≥n y verificaci√≥n opcional.
```py
def saludar(nombre: str) -> str:
    return "Hola " + nombre
```
- `nombre: str` ‚Üí tipo del argumento
- `-> str` ‚Üí tipo del valor de retorno
- Pero **no se aplican en tiempo de ejecuci√≥n** (Python no lanza error si le pasas un n√∫mero, por ejemplo).

Pues como no se aplican en tiempo de ejcucui√≥n usualmente se utilizan con **herramientas de chequeo est√°tico de tipos**, como:
- mypy 
- pyright (el motor detr√°s del soporte de Python en VSCode)
- pylance (extensi√≥n de an√°lisis para VSCode)
## Esto hace que Python sea un lenguaje "tipado est√°tico"? 
No. Python siguie **siendo un lenguaje de tipado din√°mico**, pero **ahora soporta anotaciones est√°ticas**.
# C03: Divisi√≥n entera (//)
En Python existe la divisi√≥n entera o divisi√≥n de piso (floor division). Este operador toma dos n√∫meros y realiza la divisi√≥n, pero en lugar de devolver un resultado con decimales, **redondea hacia abajo al entero m√°s cercano**. En otras palabras descarta la parte fraccionaria del resultado:
```py
# Ejemplo:
resultado_division_normal = 10 / 3  # Resultado: 3.333...
resultado_division_entera = 10 // 3 # Resultado: 3
```
La divisi√≥n normal con una barra (`/`) devuelve un n√∫mero flotante con decimales, mientras que la divisi√≥n entera con doble barra (`//`) devuelve un √∫mero entero, resultado de redondear hacia abajo el resultado de la divisi√≥n normal.
> El operador `//` es equivalente a usar la funci√≥n `math.floor()` en Python.
# C04: Comparaciones entre String (ASCII)
En Python **las comparaciones entre strings se hacen siguiendo el orden alfab√©tico lexicogr√°fico, basado en los valores Unicode (ASCII)** de cada car√°cter de **izquiera a derecha**.
Cada car√°cter tiene un valor num√©rico. por ejemplo:
| Letra | C√≥digo ASCII |
| ----- | ------------ |
| H     | 72           |
| P     | 80           |
| o     | 111          |
| y     | 121          |
| t     | 116          |
Siguiendo lo anterior, cuando en python se evalua lo siguiente:
```python
print("Hola" > "Python")  # False
```
Est√° comparando letra por letra:
`'H'` (72) vs `'P'` (80) ‚Üí como 72 < 80, entonces `"Hola"` < `"Python"` ‚Üí Resultado: False para `Hola > Python`.
# C05: Operadores l√≥gicos
| Operador | Significado     | Devuelve `True` si...                       |
| -------- | --------------- | ------------------------------------------- |
| `and`    | Y l√≥gico        | Ambas condiciones son `True`                |
| `or`     | O l√≥gico        | Al menos una condici√≥n es `True`            |
| `not`    | Negaci√≥n l√≥gica | Invierte el valor l√≥gico (`True` ‚áÑ `False`) |.

| A     | B     | A and B |
| ----- | ----- | ------- |
| False | False | False   |
| False | True  | False   |
| True  | False | False   |
| True  | True  | True    |

| A     | B     | A or B |
| ----- | ----- | ------ |
| False | False | False  |
| False | True  | True   |
| True  | False | True   |
| True  | True  | True   |

| A     | not A |
| ----- | ----- |
| False | True  |
| True  | False |
# C06: Lista
Una **lista** es una estrucura de datos **integrada** (built-in) que **puede almacenar elementos de difentes tipos**:
```py
mi_lista = [1, "Hola", True, 3.14]
```
- **Es din√°mica**: puede crecer o reducirse.
- Se puede mezclar tipos de datos.
- Se accede por √≠ndices (como en un array).

**Python no tiene arrays como tal** integrados en el lenguaje base como otros lenguajes. Pero si se puede usar arrays si se importa el m√≥dulo `array`:
```py
import array
mi_array = array.array('i', [1, 2, 3, 4])
```
- Solo permite **datos del mismo tipo** ('i' es tipo entero).
Es m√°s **eficiente** en memoria que una lista para  grandes cantidades de datos del mismo tipo.
Diferencias Clave:

| Caracter√≠stica          | Lista (`list`)         | Array (`array.array`)                    |
| ----------------------- | ---------------------- | ---------------------------------------- |
| Tipos de datos          | Mezclados              | Solo un tipo de dato                     |
| Parte del n√∫cleo Python | S√≠                     | No, requiere `import array`              |
| Flexible                | Muy flexible           | M√°s estricto                             |
| Usos comunes            | Gen√©rico, uso diario   | Eficiencia y uso t√©cnico espec√≠fico      |
| Ejemplo de creaci√≥n     | `mi_lista = [1, 2, 3]` | `mi_array = array.array('i', [1, 2, 3])` |
# C07: Constantes
En Python **no existen las variables constantes**, pero **hay una convenci√≥n para representar constantes**. En Python, se usan **letras may√∫sculas** para indicar que una variable debe ser trata como constante. por ejemplo:
```py
PI = 3.14159
MAX_USERS = 100
URL_BASE = "https://api.ejemplo.com"
```
üíé Estas variables **si se pueden modificar**, pero **por convenci√≥n no se deber√≠a hacerlo**
**Forzado de constantes**
Se puede usar una herramienta m√°s avanzada para forzar constantes como:
- clases personalizadas
- m√≥dulos externos como `typing.Final` (desde Python 3.8).
Ejemplo con `Final`:
```py
from typing import Final

PI: Final = 3.14159
PI = 3  # Esto lanzar√≠a una advertencia en linters, pero Python lo permite igual en tiempo de ejecuci√≥n.
```  
# C08: Tuplas
Una **tupla** en Python es una colecci√≥n **ordenada** e **inmutable** de elementos. Similar a una **lista**, pero con diferencia:
| Caracter√≠stica      | Lista (`list`)                | Tupla (`tuple`)                              |
| ------------------- | ----------------------------- | -------------------------------------------- |
| Sintaxis            | `[1, 2, 3]`                   | `(1, 2, 3)`                                  |
| Mutabilidad         | ‚úÖ **Mutable** (puede cambiar) | ‚ùå **Inmutable** (no puede cambiar)           |
| Rendimiento         | M√°s lenta                     | M√°s r√°pida                                   |
| Uso t√≠pico          | Datos que cambian             | Datos fijos (como coordenadas, fechas, etc.) |
| M√©todos disponibles | Muchos (como `.append()`)     | Muy pocos (`.count()`, `.index()`)           |

Un ejemplo en c√≥digo ser√≠a
```py
# Lista
lista = [1, 2, 3]
lista.append(4)  # ‚úÖ Se puede modificar

# Tupla
tupla = (1, 2, 3)
# tupla.append(4)  ‚ùå Error: las tuplas no se pueden modificar
```
Una tupla entonces deber√≠a ser una opci√≥n cuando:
- Cuando **no se quiere que los datos se modifiquen**.
- Cuando se necesita **m√°s eficiencia** (las tuplas consumen menos memoria).
- Cuando los datos son **sem√°nticamente constantes** (como (latitud, longitud)).
# C09: Sets
En Python, un `set` (conjunto) es una **colecci√≥n desordenada, sin elementos duplicados y mutable** (se puede cambiar despu√©s de ser creada)
| Caracter√≠stica                    | Detalles                                                                   |
| --------------------------------- | -------------------------------------------------------------------------- |
| ‚úÖ Elementos √∫nicos                | No permite duplicados. `{1, 2, 2, 3}` ‚Üí `{1, 2, 3}`                        |
| ‚ùå No ordenado                     | No garantiza orden al imprimirlo o recorrerlo                              |
| ‚úÖ Mutable                         | Puedes agregar o eliminar elementos con m√©todos como `.add()`, `.remove()` |
| ‚ùå No indexable                    | No puedes acceder con √≠ndices como `mi_set[0]`                             |
| ‚úÖ Permite operaciones de conjunto | uni√≥n, intersecci√≥n, diferencia, etc.                                      |
Un ejemplo en c√≥digo seria:
```py
my_set = {1, 2, 3, 4}
print(my_set)  # {1, 2, 3, 4}

my_set.add(5)
print(my_set)  # {1, 2, 3, 4, 5}

my_set.add(3)
print(my_set)  # {1, 2, 3, 4, 5} ‚Üí 3 ya exist√≠a, no se repite
```
Algunas operaciones entres sets:
```py
a = {1, 2, 3}
b = {3, 4, 5}

print(a | b)  # Uni√≥n ‚Üí {1, 2, 3, 4, 5}
print(a & b)  # Intersecci√≥n ‚Üí {3}
print(a - b)  # Diferencia ‚Üí {1, 2}
print(a ^ b)  # Diferencia sim√©trica ‚Üí {1, 2, 4, 5}
```
s
# C010: Diccionario
Un diccionario es una **colecci√≥n de datos no ordenada y mutable** que **almacena pares clave-valor**.
```py
persona = {
    "nombre": "Diego",
    "edad": 30,
    "pais": "Chile"
}
```
- `"nombre"`, `"edad"`, `"pais"` son las claves (keys).
- `"Diego"`, `30`, `"Chile"` son los valores (values).
Entonces se pude acceder de esta forma:
```py
print(persona["nombre"])  # -> Diego
```
Una diferencia clave con otros conjunto de elementos son sus indices. Solo se puden **acceder a los indices a travez de su clave**. por ejemplo:
```py
frutas = {
    "roja": "manzana",
    "amarilla": "banana",
    "verde": "pera"
}
print(frutas["amarilla"])  # "banana"
```
pero si trato de acceder a manzaja de esta forma dar√≠a un error:
```py
print(frutas[0])  # "banana"
```
Para **acceder a dicho elemento solo sirve su clave**
## Diferencia con un set
Un set es una **colecci√≥n no ordenada**, **sin elementos duplicados**. Se usa, por ejemplo para eliminar duplicados:
```py
mi_set = {1, 2, 3, 3, 4}
print(mi_set)  # -> {1, 2, 3, 4}
```
Tanto `set` como `dict` utilizan llaves (`{}`) como delimitadores, pero son estruccuras distintas:
| Caracter√≠stica | Diccionario (`dict`)     | Conjunto (`set`)            |
| -------------- | ------------------------ | --------------------------- |
| Sintaxis       | `{clave: valor}`         | `{elemento, elemento}`      |
| Tipo de datos  | Pares clave-valor        | Valores √∫nicos              |
| Acceso         | Por clave (`dic['key']`) | No admite acceso por √≠ndice |
| Ejemplo        | `{"nombre": "Diego"}`    | `{1, 2, 3}`                 |
s
# C011: dict.fromkeys()
El m√©todo `dic.fromkeys()` lo que hace es crear un nuevo diccionario usando: 
- **Una secuencia de claves**
- Un **valor com√∫n para todas esas claves**
```py
claves = ["Matem√°ticas", "F√≠sica", "Lenguaje"]
notas = dict.fromkeys(claves, 0)

print(notas)
# {'Matem√°ticas': 0, 'F√≠sica': 0, 'Lenguaje': 0}
```
s
# C012:
# C013:
# C014:
# C015:
# C016:
# C017:
# C018:
# C019:
# C020:
# C021:
# C022:
# C023:
# C024:
# C025:
# C026:
# C027:
# C028:
# C029:
# C030: